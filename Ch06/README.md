# 6.1-1
### 高さhのヒープが持つ要素数
最大値：2^(h+1) - 1  
最小値：2^h  

# 6.1-2
6.1-1から、要素数が[2^h..2^(h+1)-1]のときの高さは全て等しい。  
要素数が2^(h+1)になると高さが1増える。  
これはfloor(lgn)と一致する。

# 6.1-3
maxヒープの高さをhとする。maxヒープ条件より、高さ0に存在する要素の内の最大要素よりも、高さ1に存在する要素の内の最大要素のほうが大きい。  
高さ1の要素と高さ2の要素の間にも同様のことが言え、高さh(根)まで適用すれば、根が最大要素となることがわかる。

# 6.1-4
6.1-3を逆に考えれば、葉のどこかに置かれることがわかる。  
ヒープをH、高さをhとすると、H[2^h..2^(h+1)-1]のどこか。

# 6.1-5
minヒープ。

# 6.1-6
maxヒープではない。  
6の子に7が存在し、maxヒープ条件に反する。

# 6.2-1
### max_heapify(A, 3)の動作  
A = [27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0]

[27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0]  
[27, 17, 10, 16, 13, 3, 1, 5, 7, 12, 4, 8, 9, 0]  
[27, 17, 10, 16, 13, 9, 1, 5, 7, 12, 4, 8, 3, 0]

# 6.2-2
[heap.py](./src/heap.py)にmaxとminを統合した。  
実行時間はmax_heapifyもmin_heapifyも同じ。

# 6.2-3
何の影響もない。

# 6.2-4
何の影響もない。

# 6.3-1
### build_max_heapの動作
[5, 3, 17, 10, 84, 19, 6, 22, 9]  
[5, 3, 17, 22, 84, 19, 6, 10, 9]  
[5, 3, 19, 22, 84, 17, 6, 10, 9]  
[5, 84, 19, 22, 3, 17, 6, 10, 9]  
[84, 22, 19, 10, 3, 17, 6, 5, 9]  

# 6.3-2
max_heapifyは子がmaxヒープであると仮定しているので、子からmaxヒープを構築している。

# 6.4-1
### heap_sortの動作
[5, 13, 2, 25, 7, 17, 20, 8, 4]  
[25, 13, 20, 8, 7, 17, 2, 5, 4]  
[20, 13, 17, 8, 7, 4, 2, 5, 25]  
[17, 13, 5, 8, 7, 4, 2, 20, 25]  
[13, 8, 5, 2, 7, 4, 17, 20, 25]  
[8, 7, 5, 2, 4, 13, 17, 20, 25]  
[7, 4, 5, 2, 8, 13, 17, 20, 25]  
[5, 4, 2, 7, 8, 13, 17, 20, 25]  
[4, 2, 5, 7, 8, 13, 17, 20, 25]  
[2, 4, 5, 7, 8, 13, 17, 20, 25]

# 6.4-3
どちらもΘ(nlgn)

# 6.5-1
### heap_extract_topの動作 (maxヒープ)
[15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1]  
[1, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2]  
[13, 1, 9, 5, 12, 8, 7, 4, 0, 6, 2]  
[13, 12, 9, 5, 1, 8, 7, 4, 0, 6, 2]  
[13, 12, 9, 5, 6, 8, 7, 4, 0, 1, 2]  

# 6.5-2
### heap_insert(10)の動作 (maxヒープ)
[15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1]  
[15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, -∞]  
[15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, 10]  
[15, 13, 9, 5, 12, 10, 7, 4, 0, 6, 2, 1, 8]  
[15, 13, 10, 5, 12, 9, 7, 4, 0, 6, 2, 1, 8]  

# 6.5-3
[heap.py](./src/heap.py)にmaxとminを統合した。

# 6.5-4
ifによるkey値のチェックを常に通過させるため。
