# 7.1-1
### partitionの動作
[13 19 9 5 12 8 7 4 21 2 6 (11)]  
[(13) 19 9 5 12 8 7 4 21 2 6 (11)]  
[(13 19) 9 5 12 8 7 4 21 2 6 (11)]  
[(9) (19 13) 5 12 8 7 4 21 2 6 (11)]  
[(9 5) (13 19) 12 8 7 4 21 2 6 (11)]  
[(9 5) (13 19 12) 8 7 4 21 2 6 (11)]  
[(9 5 8) (19 12 13) 7 4 21 2 6 (11)]  
[(9 5 8 7) (12 13 19) 4 21 2 6 (11)]  
[(9 5 8 7 4) (13 19 12) 21 2 6 (11)]  
[(9 5 8 7 4) (13 19 12 21) 2 6 (11)]  
[(9 5 8 7 4 2) (19 12 21 13) 6 (11)]  
[(9 5 8 7 4 2 6) (12 21 13 19) (11)]  
[(9 5 8 7 4 2 6) (11) (21 13 19 12)]  

# 7.1-2
### A[p..r]の全要素が同じ値の場合にpartitionが返す値
partitionのパラメータrを常に返す。  

### 上記ケースでは c = (l + r) // 2 を返すようにする
[quick_sort.py](./src/quick_sort.py)に書いた。

# 7.1-3
全要素が同じかどうかの判定でΘ(n)。  
for文による繰り返しはn回行われ、それぞれ定数時間かかるのでΘ(n)。  
あわせてΘ(n)。

# 7.1-4
partitionの不等号を反対にするだけ。

# 7.2-2
7.1-2の対策が実装されていない場合、常に最悪の分割が行われる。  
Θ(n^2)。

# 7.2-3
常に最悪の分割が行われる。  
T(n) = T(n-1) + Θ(n)となり、7.2-1よりΘ(n^2)。

# 7.2-4
insertion_sortはソート済みの入力に対してはΘ(n)。  
quick_sortはソート済みの入力に対してはΘ(n^2)。  
入力がほとんどソートされた状態であれば、この漸近的限界に近いことが予想されるので、insetion_sortがquick_sortに勝る可能性は高い。

# 7.3-1
ある特定の入力が最悪時の振舞いを常に引き出すことはない（5.3節より）から？
# 7.3-2
### 最大値
S(n) = S(0) + S(n-1) + 1 = S(n-1) + 1 = Θ(n)
### 最小値
S(n) = 2S(n/2) + 1 = Θ(n)